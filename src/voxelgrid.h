//
// Created by 55241 on 2023/4/12.
//

#ifndef HW3_VOXELGRID_H
#define HW3_VOXELGRID_H
#include "definitions.h"

struct Voxel {
    int value;
    unsigned int id;
    unsigned int x_idx, y_idx, z_idx;
    bool marked;
    float resolution;
    Point3 center;
    Point3 origin;
    Point3 max_point;
    Bbox_3 box;

    Voxel(const unsigned int &x, const unsigned int &y, const unsigned int &z, const unsigned int &idx, const float reso, const Point3 &grid_origin) {
        x_idx = x;
        y_idx = y;
        z_idx = z;
        id = idx;
        resolution = reso;
        double origin_x = grid_origin.x() + resolution * x_idx;
        double origin_y = grid_origin.y() + resolution * y_idx;
        double origin_z = grid_origin.z() + resolution * z_idx;
        origin = Point3(origin_x, origin_y, origin_z);
        center = Point3(origin_x + resolution/2, origin_y + resolution/2, origin_z + resolution/2);
        max_point = Point3(origin_x + resolution, origin_y + resolution, origin_z + resolution);
        marked = false;
        box = Bbox_3(origin.x(), origin.y(), origin.z(), max_point.x(), max_point.y(), max_point.z());
    }

};

struct Voxel_grid {
    std::vector<Voxel> voxels;
    float resolution;
    Point3 origin_corner, max_corner;
    unsigned int x_num, y_num, z_num;
    float length, height, width;


    Voxel_grid(const Point3 &origin, const float &reso, const unsigned int &x_n, const unsigned int &y_n, const unsigned int &z_n):
    origin_corner(origin), resolution(reso), x_num(x_n), y_num(y_n), z_num(z_n) {
        length = x_num * resolution;
        width = y_num * resolution;
        height = z_num * resolution;
        max_corner = Point3(origin_corner.x()+length, origin_corner.y()+width, origin_corner.z()+height);
        for (unsigned int i = 0; i < z_num; i++) {
            for (unsigned int j = 0; j < y_num; j++) {
                for (unsigned int k = 0; k < x_num; k++) {
                    Voxel voxel(k ,j, i, k + j*x_num + i*x_num*y_num, resolution, origin_corner);
                    voxels.push_back(voxel);
                }
            }
        }
    }



    // overloaded function, enabling different types input arguments to call one function of the same name
    Voxel &operator()(const unsigned int &x, const unsigned int &y, const unsigned int &z) {
        assert(x >= 0 && x < x_num);
        assert(y >= 0 && y < y_num);
        assert(z >= 0 && z < z_num);
        return voxels[x + y*x_num + z*x_num*y_num];
    }

    Voxel operator()(const unsigned int &x, const unsigned int &y, const unsigned int &z) const {
        assert(x >= 0 && x < x_num);
        assert(y >= 0 && y < y_num);
        assert(z >= 0 && z < z_num);
        return voxels[x + y*x_num + z*x_num*y_num];
    }


    void voxel2obj(const std::string &output_file) {
        std::ofstream out(output_file);
        if (!out.is_open()) {std::cerr << "Error: could not open file \"" << output_file << "\" for writing." << std::endl; return;}
        out << "# OBJ file generated by output_voxels_as_obj()" << std::endl;
        int vertex_index = 1;
        for(auto voxel:voxels) {
            if (voxel.marked) {
                Point3 p1 = Point3(voxel.box.xmin(), voxel.box.ymin(), voxel.box.zmin());
                Point3 p2 = Point3(voxel.box.xmax(), voxel.box.ymin(), voxel.box.zmin());
                Point3 p3 = Point3(voxel.box.xmax(), voxel.box.ymax(), voxel.box.zmin());
                Point3 p4 = Point3(voxel.box.xmin(), voxel.box.ymax(), voxel.box.zmin());
                Point3 p5 = Point3(voxel.box.xmin(), voxel.box.ymax(), voxel.box.zmax());
                Point3 p6 = Point3(voxel.box.xmin(), voxel.box.ymin(), voxel.box.zmax());
                Point3 p7 = Point3(voxel.box.xmax(), voxel.box.ymin(), voxel.box.zmax());
                Point3 p8 = Point3(voxel.box.xmax(), voxel.box.ymax(), voxel.box.zmax());

                out << "v " << p1.x() << " " << p1.y() << " " << p1.z() << std::endl;
                out << "v " << p2.x() << " " << p2.y() << " " << p2.z() << std::endl;
                out << "v " << p3.x() << " " << p3.y() << " " << p3.z() << std::endl;
                out << "v " << p4.x() << " " << p4.y() << " " << p4.z() << std::endl;
                out << "v " << p5.x() << " " << p5.y() << " " << p5.z() << std::endl;
                out << "v " << p6.x() << " " << p6.y() << " " << p6.z() << std::endl;
                out << "v " << p7.x() << " " << p7.y() << " " << p7.z() << std::endl;
                out << "v " << p8.x() << " " << p8.y() << " " << p8.z() << std::endl;

                out << "f " << vertex_index + 3 << " " << vertex_index + 2 << " " << vertex_index + 1 << " "
                    << vertex_index << std::endl;
                out << "f " << vertex_index << " " << vertex_index + 1 << " " << vertex_index + 5 << " "
                    << vertex_index + 6 << std::endl;
                out << "f " << vertex_index + 1 << " " << vertex_index + 2 << " " << vertex_index + 7 << " "
                    << vertex_index + 6 << std::endl;
                out << "f " << vertex_index + 5 << " " << vertex_index + 6 << " " << vertex_index + 7 << " "
                    << vertex_index + 5 << std::endl;
                out << "f " << vertex_index << " " << vertex_index + 5 << " " << vertex_index + 4 << " "
                    << vertex_index + 3 << std::endl;
                out << "f " << vertex_index + 2 << " " << vertex_index + 3 << " " << vertex_index + 4 << " "
                    << vertex_index + 7 << std::endl;
                vertex_index += 8;
            }
            else
                continue;
        }

        out.close();
    }

};




#endif //HW3_VOXELGRID_H
